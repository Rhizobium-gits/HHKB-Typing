<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HHKB タイピング分析ゲーム</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', 'Menlo', 'Monaco', monospace;
            background: #f5f5f5;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
        }

        .container {
            background: white;
            border-radius: 4px;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 900px;
            width: 90%;
            border: 1px solid #ddd;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 1.8em;
            font-weight: 500;
            letter-spacing: 0.05em;
        }

        .game-area {
            display: none;
        }

        .game-area.active {
            display: block;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            background: #fafafa;
            padding: 20px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 600;
            color: #333;
        }

        .word-display {
            text-align: center;
            font-size: 3em;
            margin: 40px 0;
            min-height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 500;
            font-family: 'Courier New', monospace;
        }

        .word-display .correct {
            color: #888;
        }

        .word-display .current {
            color: #000;
            border-bottom: 3px solid #000;
            padding-bottom: 2px;
        }

        .word-display .remaining {
            color: #ccc;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            height: 100%;
            background: #333;
            transition: width 0.3s ease;
        }

        .start-screen, .result-screen {
            text-align: center;
        }

        .start-screen h2, .result-screen h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3em;
            font-weight: 500;
            letter-spacing: 0.05em;
        }

        .start-screen p {
            margin-bottom: 30px;
            color: #666;
            line-height: 1.8;
            font-size: 0.95em;
        }

        button {
            background: #333;
            color: white;
            border: none;
            padding: 12px 36px;
            font-size: 1em;
            border-radius: 2px;
            cursor: pointer;
            transition: background 0.2s;
            font-weight: 500;
            letter-spacing: 0.05em;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            background: #000;
        }

        button:active {
            background: #555;
        }

        .key-stats {
            margin-top: 30px;
        }

        .key-stats h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 500;
            letter-spacing: 0.05em;
        }

        .key-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 8px;
            margin-bottom: 30px;
        }

        .key-item {
            background: #fafafa;
            padding: 12px;
            border-radius: 2px;
            text-align: center;
            border: 1px solid #e0e0e0;
            transition: all 0.2s;
        }

        .key-item.weak {
            background: #fff;
            border-color: #000;
            border-width: 2px;
        }

        .key-item.good {
            background: #f5f5f5;
            border-color: #888;
        }

        .key-char {
            font-size: 1.8em;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
            font-family: 'Courier New', monospace;
        }

        .key-accuracy {
            font-size: 0.85em;
            color: #666;
        }

        .key-time {
            font-size: 0.75em;
            color: #999;
        }

        .weak-keys {
            background: #fafafa;
            padding: 20px;
            border-radius: 2px;
            border: 2px solid #333;
            margin-top: 20px;
        }

        .weak-keys h4 {
            color: #333;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .weak-keys p {
            color: #555;
            font-size: 1em;
            line-height: 1.6;
        }

        .countdown {
            font-size: 5em;
            color: #333;
            font-weight: 600;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .difficulty-select {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .difficulty-btn {
            padding: 8px 20px;
            font-size: 0.9em;
            background: white;
            color: #333;
            border: 1px solid #ddd;
        }

        .difficulty-btn.selected {
            background: #333;
            color: white;
            border-color: #333;
        }

        .difficulty-btn:hover {
            background: #f5f5f5;
        }

        .difficulty-btn.selected:hover {
            background: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>HHKB TYPING ANALYZER</h1>

        <div class="start-screen active" id="startScreen">
            <h2>WEAK KEY FINDER</h2>
            <p>Type the displayed characters quickly and accurately for 30 seconds.<br>
            After the game, you'll see a detailed analysis of your accuracy and response time for each key.</p>
            
            <div id="playCountDisplay" style="margin-bottom: 20px; color: #666; font-size: 0.9em;">
                <!-- プレイ回数が表示される -->
            </div>
            
            <div class="difficulty-select">
                <button class="difficulty-btn selected" data-difficulty="easy">EASY</button>
                <button class="difficulty-btn" data-difficulty="normal">NORMAL</button>
                <button class="difficulty-btn" data-difficulty="hard">HARD</button>
            </div>
            
            <button onclick="startGame()">START</button>
            
            <div id="resetButtonContainer" style="margin-top: 20px; display: none;">
                <button onclick="if(confirm('累積データをリセットしますか？')) resetCumulativeData()" 
                        style="background: #666; font-size: 0.85em; padding: 8px 20px;">
                    RESET DATA
                </button>
            </div>
        </div>

        <div class="game-area" id="gameArea">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Time Left</div>
                    <div class="stat-value" id="timer">30</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Accuracy</div>
                    <div class="stat-value" id="accuracy">100%</div>
                </div>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>

            <div class="word-display" id="wordDisplay"></div>
        </div>

        <div class="result-screen" id="resultScreen">
            <h2>RESULTS</h2>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Final Score</div>
                    <div class="stat-value" id="finalScore">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Accuracy</div>
                    <div class="stat-value" id="finalAccuracy">0%</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Avg Speed</div>
                    <div class="stat-value" id="avgSpeed">0ms</div>
                </div>
            </div>

            <div class="key-stats">
                <h3>THIS SESSION</h3>
                <div class="key-grid" id="keyGrid"></div>
            </div>

            <div class="weak-keys" id="weakKeys"></div>

            <div class="key-stats" id="cumulativeSection" style="display: none;">
                <h3>CUMULATIVE DATA (ALL SESSIONS)</h3>
                <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;" id="cumulativeInfo"></p>
                <div class="key-grid" id="cumulativeKeyGrid"></div>
                <div class="weak-keys" id="cumulativeWeakKeys"></div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button onclick="location.reload()">TRY AGAIN</button>
            </div>
        </div>
    </div>

    <script>
        // 単語リスト（難易度別） - 全キーをカバー
        const wordLists = {
            easy: [
                // 母音
                'a', 'i', 'u', 'e', 'o',
                // か行
                'ka', 'ki', 'ku', 'ke', 'ko',
                // が行
                'ga', 'gi', 'gu', 'ge', 'go',
                // さ行
                'sa', 'si', 'su', 'se', 'so',
                // ざ行
                'za', 'zi', 'zu', 'ze', 'zo',
                // た行
                'ta', 'ti', 'tu', 'te', 'to',
                // だ行
                'da', 'di', 'du', 'de', 'do',
                // な行
                'na', 'ni', 'nu', 'ne', 'no',
                // は行
                'ha', 'hi', 'hu', 'he', 'ho',
                // ば行
                'ba', 'bi', 'bu', 'be', 'bo',
                // ぱ行
                'pa', 'pi', 'pu', 'pe', 'po',
                // ま行
                'ma', 'mi', 'mu', 'me', 'mo',
                // や行
                'ya', 'yu', 'yo',
                // ら行
                'ra', 'ri', 'ru', 're', 'ro',
                // わ行
                'wa', 'wo', 'nn',
                // 拗音
                'kya', 'kyu', 'kyo', 'sha', 'shu', 'sho',
                'cha', 'chu', 'cho', 'nya', 'nyu', 'nyo',
                'hya', 'hyu', 'hyo', 'mya', 'myu', 'myo',
                'rya', 'ryu', 'ryo', 'gya', 'gyu', 'gyo',
                'ja', 'ju', 'jo', 'bya', 'byu', 'byo',
                'pya', 'pyu', 'pyo'
            ],
            normal: [
                // 動物
                'neko', 'inu', 'tori', 'sakana', 'zou', 'kirin', 'saru', 'usagi',
                'kuma', 'kitsune', 'tanuki', 'shika', 'buta', 'ushi', 'uma',
                // 自然
                'sora', 'umi', 'kaze', 'yama', 'kawa', 'mori', 'hoshi', 'tsuki',
                'kumo', 'ame', 'yuki', 'hana', 'ki', 'kusa', 'ishi', 'mizu',
                'hi', 'kage', 'niji', 'taiyou',
                // 季節・時間
                'haru', 'natsu', 'aki', 'fuyu', 'asa', 'hiru', 'yoru', 'yoake',
                'yuugata', 'mayonaka',
                // 色
                'aka', 'ao', 'ki', 'midori', 'shiro', 'kuro', 'murasaki',
                'pinku', 'orenji', 'chairo',
                // 場所
                'ie', 'heya', 'niwa', 'michi', 'mura', 'machi', 'eki', 'kouen',
                'gakkou', 'toshokan', 'byouin',
                // 食べ物
                'gohan', 'pan', 'niku', 'yasai', 'kudamono', 'mikan', 'ringo',
                'momo', 'sakuranbo', 'budou', 'ichigo',
                // 感情・状態
                'shiawase', 'kanashii', 'tanoshii', 'ureshii', 'sabishii',
                'kowai', 'yasashii', 'tsuyoi', 'yowai',
                // その他
                'hikari', 'kage', 'oto', 'koe', 'kotoba', 'namae', 'kokoro',
                'chikara', 'inochi', 'yume', 'omoi', 'negai'
            ],
            hard: [
                // 日本語の言葉
                'konnichiwa', 'arigatou', 'ganbatte', 'otsukare', 'subarashii',
                'tanoshikatta', 'ureshikatta', 'kanashikatta', 'kowakatta',
                'muzukashii', 'yasashikatta', 'oishikatta', 'atarashii',
                'furukatta', 'atsukatta', 'samukatta', 'suzushii', 'atatakai',
                // プログラミング用語
                'programming', 'javascript', 'typescript', 'python', 'algorithm',
                'function', 'variable', 'constant', 'array', 'object', 'string',
                'number', 'boolean', 'undefined', 'null', 'class', 'interface',
                'async', 'await', 'promise', 'callback', 'method', 'property',
                'parameter', 'argument', 'return', 'import', 'export', 'module',
                'component', 'state', 'props', 'render', 'lifecycle',
                // コンピュータ用語
                'computer', 'keyboard', 'mouse', 'display', 'monitor', 'screen',
                'processor', 'memory', 'storage', 'database', 'network', 'server',
                'client', 'browser', 'application', 'software', 'hardware',
                'internet', 'website', 'email', 'download', 'upload',
                // 英単語（よく使う）
                'hello', 'world', 'welcome', 'thank', 'please', 'sorry',
                'excuse', 'question', 'answer', 'problem', 'solution',
                'example', 'document', 'project', 'version', 'update',
                'create', 'delete', 'modify', 'search', 'replace',
                // 記号を含む
                'hello.js', 'index.html', 'style.css', 'app.tsx',
                'config.json', 'package.json', 'README.md',
                // 数字を含む
                'test123', 'user001', 'item999', 'page01', 'version2',
                // 複雑な組み合わせ
                'konpyuutaa', 'puroguramu', 'intaanetto', 'deetabesu',
                'fairu', 'forudaa', 'daunnroodo', 'appuroodo', 'sofutowea',
                'haadowea', 'nettowaku', 'saabaa', 'kuraiento', 'burauzaa'
            ]
        };

        let currentDifficulty = 'easy';
        let gameActive = false;
        let currentWord = '';
        let currentIndex = 0;
        let score = 0;
        let totalKeystrokes = 0;
        let correctKeystrokes = 0;
        let timeLeft = 30;
        let timerInterval;
        let keyStats = {};
        let wordStartTime;
        let playCount = 0;

        // 累積データの管理
        function loadCumulativeData() {
            const data = localStorage.getItem('hhkbTypingData');
            if (data) {
                return JSON.parse(data);
            }
            return {
                totalPlays: 0,
                keyData: {}
            };
        }

        function saveCumulativeData(cumulativeData) {
            localStorage.setItem('hhkbTypingData', JSON.stringify(cumulativeData));
        }

        function mergeToCumulativeData() {
            const cumulativeData = loadCumulativeData();
            cumulativeData.totalPlays++;

            // 今回のデータを累積データにマージ
            Object.keys(keyStats).forEach(key => {
                if (!cumulativeData.keyData[key]) {
                    cumulativeData.keyData[key] = {
                        totalAttempts: 0,
                        totalCorrect: 0,
                        allTimes: []
                    };
                }
                
                cumulativeData.keyData[key].totalAttempts += keyStats[key].attempts;
                cumulativeData.keyData[key].totalCorrect += keyStats[key].correct;
                cumulativeData.keyData[key].allTimes.push(...keyStats[key].times);
                
                // 時間データが多すぎる場合は最新の100件のみ保持
                if (cumulativeData.keyData[key].allTimes.length > 100) {
                    cumulativeData.keyData[key].allTimes = 
                        cumulativeData.keyData[key].allTimes.slice(-100);
                }
            });

            saveCumulativeData(cumulativeData);
            return cumulativeData;
        }

        function resetCumulativeData() {
            localStorage.removeItem('hhkbTypingData');
            location.reload();
        }

        // 難易度選択
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
                this.classList.add('selected');
                currentDifficulty = this.dataset.difficulty;
            });
        });

        // ページ読み込み時にプレイ回数を表示
        window.addEventListener('DOMContentLoaded', function() {
            const cumulativeData = loadCumulativeData();
            const playCountDisplay = document.getElementById('playCountDisplay');
            const resetButtonContainer = document.getElementById('resetButtonContainer');
            
            if (cumulativeData.totalPlays > 0) {
                playCountDisplay.innerHTML = `Total plays: <strong>${cumulativeData.totalPlays}</strong> times`;
                playCountDisplay.style.display = 'block';
                resetButtonContainer.style.display = 'block';
            } else {
                playCountDisplay.style.display = 'none';
                resetButtonContainer.style.display = 'none';
            }
        });

        function startGame() {
            document.getElementById('startScreen').classList.remove('active');
            
            // カウントダウン
            let countdown = 3;
            const wordDisplay = document.getElementById('wordDisplay');
            wordDisplay.innerHTML = `<div class="countdown">${countdown}</div>`;
            document.getElementById('gameArea').classList.add('active');
            
            const countInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    wordDisplay.innerHTML = `<div class="countdown">${countdown}</div>`;
                } else {
                    clearInterval(countInterval);
                    initGame();
                }
            }, 1000);
        }

        function initGame() {
            gameActive = true;
            score = 0;
            totalKeystrokes = 0;
            correctKeystrokes = 0;
            timeLeft = 30;
            keyStats = {};
            
            nextWord();
            
            timerInterval = setInterval(() => {
                timeLeft--;
                document.getElementById('timer').textContent = timeLeft;
                
                const progress = ((30 - timeLeft) / 30) * 100;
                document.getElementById('progressBar').style.width = progress + '%';
                
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }

        function nextWord() {
            const words = wordLists[currentDifficulty];
            currentWord = words[Math.floor(Math.random() * words.length)];
            currentIndex = 0;
            wordStartTime = Date.now();
            updateWordDisplay();
        }

        function updateWordDisplay() {
            const display = document.getElementById('wordDisplay');
            const correct = currentWord.slice(0, currentIndex);
            const current = currentWord[currentIndex] || '';
            const remaining = currentWord.slice(currentIndex + 1);
            
            display.innerHTML = `
                <span class="correct">${correct}</span><span class="current">${current}</span><span class="remaining">${remaining}</span>
            `;
        }

        document.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            
            const key = e.key.toLowerCase();
            const expectedKey = currentWord[currentIndex];
            
            // 特殊キーは無視
            if (key.length > 1 && key !== 'backspace') return;
            
            totalKeystrokes++;
            
            // キーの統計を初期化
            if (!keyStats[expectedKey]) {
                keyStats[expectedKey] = {
                    attempts: 0,
                    correct: 0,
                    times: []
                };
            }
            
            keyStats[expectedKey].attempts++;
            
            if (key === expectedKey) {
                correctKeystrokes++;
                keyStats[expectedKey].correct++;
                
                const responseTime = Date.now() - wordStartTime;
                keyStats[expectedKey].times.push(responseTime);
                
                currentIndex++;
                
                if (currentIndex >= currentWord.length) {
                    score += currentWord.length * 10;
                    document.getElementById('score').textContent = score;
                    nextWord();
                } else {
                    wordStartTime = Date.now();
                    updateWordDisplay();
                }
            }
            
            updateAccuracy();
        });

        function updateAccuracy() {
            const accuracy = totalKeystrokes > 0 
                ? Math.round((correctKeystrokes / totalKeystrokes) * 100) 
                : 100;
            document.getElementById('accuracy').textContent = accuracy + '%';
        }

        function endGame() {
            gameActive = false;
            clearInterval(timerInterval);
            
            document.getElementById('gameArea').classList.remove('active');
            showResults();
        }

        function showResults() {
            const finalAccuracy = totalKeystrokes > 0 
                ? Math.round((correctKeystrokes / totalKeystrokes) * 100) 
                : 100;
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalAccuracy').textContent = finalAccuracy + '%';
            
            // 平均速度計算
            let totalTime = 0;
            let totalResponses = 0;
            Object.values(keyStats).forEach(stat => {
                totalTime += stat.times.reduce((a, b) => a + b, 0);
                totalResponses += stat.times.length;
            });
            const avgSpeed = totalResponses > 0 ? Math.round(totalTime / totalResponses) : 0;
            document.getElementById('avgSpeed').textContent = avgSpeed + 'ms';
            
            // 今回のセッションのキー統計表示
            displayKeyStats();
            
            // 累積データに保存
            const cumulativeData = mergeToCumulativeData();
            
            // 累積データの表示
            if (cumulativeData.totalPlays >= 1) {
                displayCumulativeStats(cumulativeData);
            }
            
            document.getElementById('resultScreen').style.display = 'block';
        }

        function displayKeyStats() {
            const keyGrid = document.getElementById('keyGrid');
            keyGrid.innerHTML = '';
            
            const sortedKeys = Object.entries(keyStats)
                .sort((a, b) => {
                    const accuracyA = a[1].correct / a[1].attempts;
                    const accuracyB = b[1].correct / b[1].attempts;
                    return accuracyA - accuracyB;
                });
            
            const weakKeys = [];
            
            sortedKeys.forEach(([key, stats]) => {
                const accuracy = Math.round((stats.correct / stats.attempts) * 100);
                const avgTime = stats.times.length > 0 
                    ? Math.round(stats.times.reduce((a, b) => a + b, 0) / stats.times.length) 
                    : 0;
                
                const keyItem = document.createElement('div');
                keyItem.className = 'key-item';
                
                if (accuracy < 70 || avgTime > 800) {
                    keyItem.classList.add('weak');
                    weakKeys.push({ key, accuracy, avgTime });
                } else if (accuracy >= 90 && avgTime < 500) {
                    keyItem.classList.add('good');
                }
                
                keyItem.innerHTML = `
                    <div class="key-char">${key}</div>
                    <div class="key-accuracy">ACC: ${accuracy}%</div>
                    <div class="key-time">AVG: ${avgTime}ms</div>
                `;
                
                keyGrid.appendChild(keyItem);
            });
            
            // 苦手なキーの表示
            if (weakKeys.length > 0) {
                const weakKeysDiv = document.getElementById('weakKeys');
                const keyList = weakKeys.map(k => `「${k.key}」(${k.accuracy}%, ${k.avgTime}ms)`).join(', ');
                weakKeysDiv.innerHTML = `
                    <h4>KEYS THAT NEED PRACTICE</h4>
                    <p>${keyList}</p>
                    <p style="margin-top: 10px; font-size: 0.9em;">Focus on practicing these keys to improve your typing accuracy.</p>
                `;
                weakKeysDiv.style.display = 'block';
            } else {
                document.getElementById('weakKeys').style.display = 'none';
            }
        }

        function displayCumulativeStats(cumulativeData) {
            document.getElementById('cumulativeSection').style.display = 'block';
            document.getElementById('cumulativeInfo').textContent = 
                `Based on ${cumulativeData.totalPlays} sessions`;
            
            const cumulativeKeyGrid = document.getElementById('cumulativeKeyGrid');
            cumulativeKeyGrid.innerHTML = '';
            
            const sortedKeys = Object.entries(cumulativeData.keyData)
                .filter(([key, stats]) => stats.totalAttempts > 0)
                .sort((a, b) => {
                    const accuracyA = a[1].totalCorrect / a[1].totalAttempts;
                    const accuracyB = b[1].totalCorrect / b[1].totalAttempts;
                    return accuracyA - accuracyB;
                });
            
            const cumulativeWeakKeys = [];
            
            sortedKeys.forEach(([key, stats]) => {
                const accuracy = Math.round((stats.totalCorrect / stats.totalAttempts) * 100);
                const avgTime = stats.allTimes.length > 0 
                    ? Math.round(stats.allTimes.reduce((a, b) => a + b, 0) / stats.allTimes.length) 
                    : 0;
                
                const keyItem = document.createElement('div');
                keyItem.className = 'key-item';
                
                if (accuracy < 70 || avgTime > 800) {
                    keyItem.classList.add('weak');
                    cumulativeWeakKeys.push({ key, accuracy, avgTime, attempts: stats.totalAttempts });
                } else if (accuracy >= 90 && avgTime < 500) {
                    keyItem.classList.add('good');
                }
                
                keyItem.innerHTML = `
                    <div class="key-char">${key}</div>
                    <div class="key-accuracy">ACC: ${accuracy}%</div>
                    <div class="key-time">AVG: ${avgTime}ms</div>
                    <div style="font-size: 0.7em; color: #aaa; margin-top: 3px;">n=${stats.totalAttempts}</div>
                `;
                
                cumulativeKeyGrid.appendChild(keyItem);
            });
            
            // 累積データの苦手なキーの表示
            if (cumulativeWeakKeys.length > 0) {
                const cumulativeWeakKeysDiv = document.getElementById('cumulativeWeakKeys');
                
                // 試行回数でソート（より多く失敗しているキーを優先）
                cumulativeWeakKeys.sort((a, b) => b.attempts - a.attempts);
                
                const keyList = cumulativeWeakKeys
                    .slice(0, 10) // 上位10個まで表示
                    .map(k => `「${k.key}」(${k.accuracy}%, ${k.avgTime}ms, n=${k.attempts})`)
                    .join(', ');
                
                cumulativeWeakKeysDiv.innerHTML = `
                    <h4>KEYS THAT NEED PRACTICE (OVERALL)</h4>
                    <p>${keyList}</p>
                    <p style="margin-top: 10px; font-size: 0.9em;">
                        These keys show consistent weakness across all your sessions. Focus on practicing these keys.
                    </p>
                `;
                cumulativeWeakKeysDiv.style.display = 'block';
            } else {
                document.getElementById('cumulativeWeakKeys').style.display = 'none';
            }
        }
    </script>
</body>
</html>
